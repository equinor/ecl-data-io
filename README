ecl-data-io
===========

Extensible parser of the eclipse data input format. This
is a native python parser library for the `.DATA` format used
by many petroleum field simulators. Note that this library is

* Not feature complete, but extensible
* Does not adhere to a single specification, but is flexible
* Can read included files ('.INC' or '.grdecl'), but only
  when the included file follows reasonable conventions.

Overview of parsing
===================

The parser is based on being a collection of subparsers with their own state.
Each subparser is a generator of `Record`s.  These are activated by keywords,
so, for instance, when the parser encounters the `SKIP` keyword, the
`SkipSubparser.parse` generator is called (which has access to the state of all
other subparsers). It then consumes from the file until the `ENDSKIP` keyword
is encountered and yields a `SkippedSection` record. The parser then looks at
keyword on the next line to see which subparser should be called next.

## Non-strict parsing

Since any number of keywords can occurr in a `.DATA` file, we support
non-strict parsing through the `ecl_data_io.parse(strict=False)` parameter,
meaning lines not containing a recognized keyword are ignored until a
recognized keyword is reached.  Note that this might fail to correctly parse a
file. A warning is given when non-strict parsing is encountered.

Default supported keywords
==========================

Comments of the form '--' are built in, and can only be turned off (or changed) by setting
the `ecl_data_io.parse(comment_token='--')` to `None`.

The following keywords are supported by the collection of parsers in
`ecl_data_io.subparsers.DEFAULT_SUBPARSERS`:

* SKIP, SKIP100, SKIP300, ENDSKIP
* COLUMNS
* MESSAGE

In addition records of the form

```
KEYWORD
 1 2 3 4 /
```

can be read by adding subparsers of the form
`SimpleDataRecord(keyword="KEYWORD")`, and data records of the form

```
DKEYWORD
 1 2 3 4 /
 5 6 7 8 /
/
```

are read by `DoubleDataRecord(keyword="DKEYWORD")`. Some records
require that you know a part of the parsed state in order to know how many
subrecords to read:

```
THREEREC
 1 2 /
 4 5 /
 6 7 /
```

In that case, you can use the `FixedSizeDataRecord(keyword="THREEREC",
state_lookup=get_number_of_records)` where `get_number_of_records` returns the
number of records when passed the subparser containing the state:

```
def get_number_of_records(subparsers):
    for subparser in subparsers:
        if isinstance(subparser, ThisSubparserContainsTheRecord):
            return subparser.the_number_of_records
    raise ValueError("missing dependent subparser")
```

Subparsers of commonly used keywords can be found in
`ecl_data_io.subparsers.COMMON_SUBPARSERS`, and a reasonable
parser of `.DATA` files can be gotten by running

```
ecl_data_io.parser(filepath, subparsers=DEFAULT_SUBPARSERS+COMMON_SUBPARSERS, strict=True)
```

Note: The `COMMON_SUBPARSERS` take a strict approach
to terminating slashes. Some keywords have optional
terminating slashes in eclipse100. For simplicity the
`COMMON_SUBPARSERS` assumes terminating slashes are
always present.

Note: COMMON_SUBPARSERS skips as if using eclipse300.
